# Utilility functions for pileup SNPs
# Author: Yuanhua Huang
# Date: 22/08/2018

## TODO: samFile.fetch is more efficient, but may gives
## low quality reads, e.g., deletion or refskip

## Note, pileup is not the fastest way, fetch reads and deal 
## with CIGARs will be faster.

import pysam

VCF_HEADER = (
    '##fileformat=VCFv4.2\n'
    '##generated by pileup_pysam.py v0.1.4\n'
    '##FILTER=<ID=PASS,Description="All filters passed">\n'
    '##FORMAT=<ID=DP,Number=1,Type=int,Description="total counts for ALT and '
    'REF">\n'
    '##FORMAT=<ID=AD,Number=1,Type=int,Description="total counts for ALT">\n'
    '##FORMAT=<ID=OTH,Number=1,Type=int,Description="total counts for other '
    'bases from REF and ALT">\n'
    '##FORMAT=<ID=ALL,Number=5,Type=int,Description="total counts for all '
    'bases in order of A,C,G,T,N">\n')

BASE_IDX = {"A": 0, "C": 1, "G": 2, "T": 3, "N": 4}
BASE_ZERO = {"A": 0, "C": 0, "G": 0, "T": 0, "N": 0}


def pileup_10X(samFile, barcodes, out_file, chrom=None, cell_tag="CR", 
               min_COUNT=20, min_MAF=0.1, verbose=True):
    """Pileup allelic specific expression from a list of pysam objects
    """
    if type(samFile) == str:
        samFile = pysam.Samfile(samFile)
    if chrom != None:
        if chrom not in samFile.references:
            if chrom.startswith("chr"):
                chrom = chrom.split("chr")[1]
            else:
                chrom = "chr" + chrom
        if chrom not in samFile.references:
            print("Can't find references %s in samFile" %chrom)
            return None
    if out_file is not None:
        fid = open(out_file, "w")
        fid.writelines(VCF_HEADER)
        HEAD_LINE = ["#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", 
                     "INFO", "FORMAT"] + barcodes
        fid.writelines("\t".join(HEAD_LINE) + "\n")
    
    base_idx = {"A": 0, "C": 1, "G": 2, "T": 3, "N": 4}
    base_zero = {"A": 0, "C": 0, "G": 0, "T": 0, "N": 0}
    
    POS_CNT = 0
    vcf_lines_all = []
    for pileupcolumn in samFile.pileup(contig=chrom):
        POS_CNT += 1
        if verbose and POS_CNT % 1000000 == 0:
            print("%s: %dM positions processed." %(chrom, POS_CNT/1000000))
        if pileupcolumn.n < min_COUNT:
            continue
           
        # TODO: speedup the barcode search here to n*log(n), instead of n^2
        # tags_list = []
        # base_list = []
        # base_cells = [[0] * 5] * len(barcodes) ### reference not copy!!!
        base_merge = BASE_ZERO.copy()
        base_cells = [[0,0,0,0,0] for x in barcodes]
        for pileupread in pileupcolumn.pileups:
            # query position is None if is_del or is_refskip is set.
            if pileupread.is_del or pileupread.is_refskip:
                continue
                
            #TODO: check reads quality
            _read = pileupread.alignment           
            _base = _read.query_sequence[pileupread.query_position - 1].upper()
            if cell_tag is not None and _read.has_tag(cell_tag):
                # base_list.append(_base)
                # tags_list.append(_read.get_tag(cell_tag))
                
                _tag = _read.get_tag(cell_tag)
                if _tag in barcodes:
                    _idx = barcodes.index(_tag)
                    base_cells[_idx][BASE_IDX[_base]] += 1
                    base_merge[_base] += 1

        base_sorted = sorted(base_merge, key=base_merge.__getitem__, reverse=True)
        REF = base_sorted[0]
        ALT = base_sorted[1]
        min_cnt_2nd = min_MAF * sum(base_merge.values())      
        if sum(base_merge.values()) < min_COUNT or base_merge[ALT] < min_cnt_2nd:
            continue
            
        line = get_vcf_line(base_merge, base_cells, pileupcolumn.reference_name, 
                            pileupcolumn.pos, REF, ALT)
        if out_file is None:
            vcf_lines_all.append(line)
        else:
            fid.writelines(line)
    
    if out_file is not None:
        fid.close()     
    return vcf_lines_all
            
def get_vcf_line(base_merge, base_cells, chrom, POS, REF, ALT):
    """Convert the counts for all bases into a vcf line
    """
    FORMAT = "AD:DP:OTH:ALL"
    REF_cnt = base_merge[REF]
    ALT_cnt = base_merge[ALT]
    OTH_cnt = sum(base_merge.values()) - REF_cnt - ALT_cnt
    
    INFO = "AD=%d;DP=%d;OTH=%d" %(ALT_cnt, ALT_cnt+REF_cnt, OTH_cnt)
    
    cells_str = []
    for _base_cell in base_cells:
        if sum(_base_cell) == 0:
            cells_str.append(".:.:.:.")
        else:
            _REF_cnt = _base_cell[BASE_IDX[REF]]
            _ALT_cnt = _base_cell[BASE_IDX[ALT]]
            _OTH_cnt = sum(_base_cell) - _REF_cnt - _ALT_cnt
    
            all_str = ",".join([str(x) for x in _base_cell])
            cnt_lst = [str(_ALT_cnt), str(_ALT_cnt + _REF_cnt), str(_OTH_cnt)]
            out_lst = ":".join(cnt_lst + [all_str])
            cells_str.append(out_lst)
    
    vcf_val = [chrom, str(POS), ".", REF, ALT, ".", "PASS", INFO, FORMAT]
    vcf_line = "\t".join(vcf_val + cells_str) + "\n"
    
    return vcf_line
