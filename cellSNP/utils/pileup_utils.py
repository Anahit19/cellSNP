# Utilility functions for pileup SNPs
# Author: Yuanhua Huang
# Date: 22/08/2018

## TODO: samFile.fetch is more efficient, but may gives
## low quality reads, e.g., deletion or refskip

## Note, pileup is not the fastest way, fetch reads and deal 
## with CIGARs will be faster.

import pysam
from .base_utils import id_mapping, unique_list

VCF_HEADER = (
    '##fileformat=VCFv4.2\n'
    '##generated by pileup_pysam.py v0.1.4\n'
    '##FILTER=<ID=PASS,Description="All filters passed">\n'
    '##FORMAT=<ID=DP,Number=1,Type=int,Description="total counts for ALT and '
    'REF">\n'
    '##FORMAT=<ID=AD,Number=1,Type=int,Description="total counts for ALT">\n'
    '##FORMAT=<ID=OTH,Number=1,Type=int,Description="total counts for other '
    'bases from REF and ALT">\n'
    '##FORMAT=<ID=ALL,Number=5,Type=int,Description="total counts for all '
    'bases in order of A,C,G,T,N">\n')

VCF_COLUMN = ["#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", 
              "INFO", "FORMAT"]

BASE_IDX = {"A": 0, "C": 1, "G": 2, "T": 3, "N": 4}
BASE_ZERO = {"A": 0, "C": 0, "G": 0, "T": 0, "N": 0}

def pileup_10X(samFile, barcodes, out_file, chrom=None, cell_tag="CR", 
               UMI_tag="UR", min_COUNT=20, min_MAF=0.1, min_MAPQ=20, 
               max_FLAG=4096, verbose=True):
    """Pileup allelic specific expression from a list of pysam objects
    """
    if type(samFile) == str:
        samFile = pysam.Samfile(samFile)
    if chrom != None:
        if chrom not in samFile.references:
            if chrom.startswith("chr"):
                chrom = chrom.split("chr")[1]
            else:
                chrom = "chr" + chrom
        if chrom not in samFile.references:
            print("Can't find references %s in samFile" %chrom)
            return None
    if out_file is not None:
        fid = open(out_file, "w")
        fid.writelines(VCF_HEADER)
        fid.writelines("\t".join(VCF_COLUMN + barcodes) + "\n")
    
    POS_CNT = 0
    vcf_lines_all = []
    for pileupcolumn in samFile.pileup(contig=chrom):
        POS_CNT += 1
        if verbose and POS_CNT % 1000000 == 0:
            print("%s: %dM positions processed." %(chrom, POS_CNT/1000000))
        if pileupcolumn.n < min_COUNT:
            continue
           
        UMIs_list = []
        cell_list = []
        base_list = []
        for pileupread in pileupcolumn.pileups:
            # query position is None if is_del or is_refskip is set.
            if pileupread.is_del or pileupread.is_refskip:
                continue
            query_POS = pileupread.query_position
                
            # Check reads quality and existence of cell and UMI tags
            _read = pileupread.alignment
            if _read.mapq < min_MAPQ or _read.flag > max_FLAG: 
                continue
            if cell_tag is not None and _read.has_tag(cell_tag) == False: 
                continue
            if UMI_tag is not None and _read.has_tag(UMI_tag) == False: 
                continue
            if UMI_tag is not None:
                UMIs_list.append(_read.get_tag(UMI_tag))
            if cell_tag is not None:
                cell_list.append(_read.get_tag(cell_tag))
            base_list.append(_read.query_sequence[query_POS - 1].upper())
        if len(cell_list) < min_COUNT:
            continue
            
        base_merge, base_cells = map_barcodes(base_list, cell_list,
            UMIs_list, barcodes)
        
        vcf_line = get_vcf_line(base_merge, base_cells, 
            pileupcolumn.reference_name, pileupcolumn.pos, min_COUNT, min_MAF)

        if vcf_line is not None:
            if out_file is None:
                vcf_lines_all.append(vcf_line)
            else:
                fid.writelines(vcf_line)
    
    if out_file is not None:
        fid.close() 
    return vcf_lines_all


def map_barcodes(base_list, cell_list, UMIs_list, barcodes):
    """map cell barcodes and pileup bases
    """
    base_merge = BASE_ZERO.copy()
    base_cells = [[0,0,0,0,0] for x in barcodes]

    ## Method 1
    # for i in range(len(cell_list)):
    #     _tag = cell_list[i]
    #     _base = base_list[i]
    #     if _tag in barcodes:
    #         _idx = barcodes.index(_tag)
    #         base_cells[_idx][BASE_IDX[_base]] += 1
    #         base_merge[_base] += 1    

    ## Method 2
    # count UMI rather than reads
    if len(UMIs_list) == len(base_list):
        UMIs_uniq, UMIs_idx, tmp = unique_list(UMIs_list)
        cell_list = [cell_list[i] for i in UMIs_idx]
        base_list = [base_list[i] for i in UMIs_idx]

    match_idx = id_mapping(cell_list, barcodes, uniq_ref_only=False, IDs2_sorted=True)
    
    for i in range(len(base_list)):
        _idx = match_idx[i]
        _base = base_list[i]
        if _idx is not None:
            base_cells[_idx][BASE_IDX[_base]] += 1
            base_merge[_base] += 1

    return base_merge, base_cells


def get_vcf_line(base_merge, base_cells, chrom, POS, min_COUNT, min_MAF):
    """Convert the counts for all bases into a vcf line
    """
    base_sorted = sorted(base_merge, key=base_merge.__getitem__, reverse=True)
    REF = base_sorted[0]
    ALT = base_sorted[1]
    min_cnt_2nd = min_MAF * sum(base_merge.values())      
    if sum(base_merge.values()) < min_COUNT or base_merge[ALT] < min_cnt_2nd:
        return None

    FORMAT = "AD:DP:OTH:ALL"
    REF_cnt = base_merge[REF]
    ALT_cnt = base_merge[ALT]
    OTH_cnt = sum(base_merge.values()) - REF_cnt - ALT_cnt
    
    INFO = "AD=%d;DP=%d;OTH=%d" %(ALT_cnt, ALT_cnt+REF_cnt, OTH_cnt)
    
    cells_str = []
    for _base_cell in base_cells:
        if sum(_base_cell) == 0:
            cells_str.append(".:.:.:.")
        else:
            _REF_cnt = _base_cell[BASE_IDX[REF]]
            _ALT_cnt = _base_cell[BASE_IDX[ALT]]
            _OTH_cnt = sum(_base_cell) - _REF_cnt - _ALT_cnt
    
            all_str = ",".join([str(x) for x in _base_cell])
            cnt_lst = [str(_ALT_cnt), str(_ALT_cnt + _REF_cnt), str(_OTH_cnt)]
            out_lst = ":".join(cnt_lst + [all_str])
            cells_str.append(out_lst)
    
    vcf_val = [chrom, str(POS), ".", REF, ALT, ".", "PASS", INFO, FORMAT]
    vcf_line = "\t".join(vcf_val + cells_str) + "\n"
    
    return vcf_line
